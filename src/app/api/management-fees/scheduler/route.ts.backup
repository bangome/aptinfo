import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

const API_KEY = process.env.NEXT_PUBLIC_DATA_GO_KR_SERVICE_KEY;
const SCHEDULER_SECRET = process.env.SCHEDULER_SECRET || 'your-scheduler-secret';
const COMMON_COST_BASE_URL = 'https://apis.data.go.kr/1613000/AptCmnuseManageCostServiceV2';
const INDIVIDUAL_COST_BASE_URL = 'https://apis.data.go.kr/1613000/AptIndvdlzManageCostServiceV2';

// 강화된 재시도 로직
async function fetchWithRetry(url: string, maxRetries: number = 5, delayMs: number = 1000): Promise<Response> {
  let lastError: Error = new Error('Unknown error');
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0 (compatible; ManagementFeeBot/1.0)',
          'Connection': 'keep-alive',
          'Cache-Control': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < maxRetries) {
        const delay = Math.min(delayMs * attempt, 5000);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
}

// 아파트별 관리비 수집 함수 (간소화된 버전)
async function collectManagementFeeForApartment(kaptCode: string, kaptName: string, year: number, month: number) {
  const searchDate = `${year}${month.toString().padStart(2, '0')}`;
  const encodedApiKey = encodeURIComponent(API_KEY!);
  
  // 엔드포인트 정의
  const endpoints = [
    // 공용관리비 (17개)
    { name: '청소비', url: 'getHsmpCleaningCostInfoV2', key: 'cleanCost', dbField: 'cleaning_cost', service: 'common' },
    { name: '경비비', url: 'getHsmpGuardCostInfoV2', key: 'guardCost', dbField: 'guard_cost', service: 'common' },
    { name: '소독비', url: 'getHsmpDisinfectionCostInfoV2', key: 'disinfCost', dbField: 'disinfection_cost', service: 'common' },
    { name: '승강기유지비', url: 'getHsmpElevatorMntncCostInfoV2', key: 'elevCost', dbField: 'elevator_cost', service: 'common' },
    { name: '수선비', url: 'getHsmpRepairsCostInfoV2', key: 'lrefCost1', dbField: 'repairs_cost', service: 'common' },
    { name: '시설유지비', url: 'getHsmpFacilityMntncCostInfoV2', key: 'lrefCost2', dbField: 'facility_cost', service: 'common' },
    { name: '차량유지비', url: 'getHsmpVhcleMntncCostInfoV2', key: 'fuelCost', dbField: 'vehicle_cost', service: 'common' },
    { name: '재해예방비', url: 'getHsmpDisasterPreventionCostInfoV2', key: 'lrefCost4', dbField: 'disaster_cost', service: 'common' },
    { name: '기타부대비용', url: 'getHsmpEtcCostInfoV2', key: 'careItemCost', dbField: 'etc_cost', service: 'common' },
    { name: '제사무비', url: 'getHsmpOfcrkCostInfoV2', key: 'officeSupply', dbField: 'office_cost', service: 'common' },
    { name: '피복비', url: 'getHsmpClothingCostInfoV2', key: 'clothesCost', dbField: 'clothing_cost', service: 'common' },
    { name: '교육훈련비', url: 'getHsmpEduTraingCostInfoV2', key: 'eduCost', dbField: 'education_cost', service: 'common' },
    { name: '지능형홈네트워크설비유지비', url: 'getHsmpHomeNetworkMntncCostInfoV2', key: 'hnetwCost', dbField: 'home_network_cost', service: 'common' },
    { name: '안전점검비', url: 'getHsmpSafetyCheckUpCostInfoV2', key: 'lrefCost3', dbField: 'safety_cost', service: 'common' },
    { name: '위탁관리수수료', url: 'getHsmpConsignManageFeeInfoV2', key: 'manageCost', dbField: 'management_cost', service: 'common' },
    { name: '인건비', url: 'getHsmpLaborCostInfoV2', key: 'pay', dbField: 'labor_cost', service: 'common' },
    { name: '제세공과금', url: 'getHsmpTaxdueInfoV2', key: 'telCost', dbField: 'tax_cost', service: 'common' },
    // 개별사용료 (10개)
    { name: '난방비', url: 'getHsmpHeatCostInfoV2', key: 'heatC', dbField: 'heating_cost', service: 'individual' },
    { name: '급탕비', url: 'getHsmpHotWaterCostInfoV2', key: 'waterHotC', dbField: 'hot_water_cost', service: 'individual' },
    { name: '전기료', url: 'getHsmpElectricityCostInfoV2', key: 'electC', dbField: 'electricity_cost', service: 'individual' },
    { name: '수도료', url: 'getHsmpWaterCostInfoV2', key: 'waterCoolC', dbField: 'water_cost', service: 'individual' },
    { name: '가스사용료', url: 'getHsmpGasRentalFeeInfoV2', key: 'gasC', dbField: 'gas_cost', service: 'individual' },
    { name: '생활폐기물수수료', url: 'getHsmpDomesticWasteFeeInfoV2', key: 'scrap', dbField: 'waste_cost', service: 'individual' },
    { name: '입주자대표회의운영비', url: 'getHsmpMovingInRepresentationMtgInfoV2', key: 'preMeet', dbField: 'meeting_cost', service: 'individual' },
    { name: '건물보험료', url: 'getHsmpBuildingInsuranceFeeInfoV2', key: 'buildInsu', dbField: 'insurance_cost', service: 'individual' },
    { name: '선거관리위원회운영비', url: 'getHsmpElectionOrpnsInfoV2', key: 'electionMng', dbField: 'election_cost', service: 'individual' },
    { name: '정화조오물수수료', url: 'getHsmpWaterPurifierTankFeeInfoV2', key: 'purifi', dbField: 'purifier_cost', service: 'individual' }
  ];

  const result: any = {
    kapt_code: kaptCode,
    kapt_name: kaptName,
    year,
    month,
    common_fee: 0,
    individual_fee: 0,
    total_fee: 0,
    success_rate: 0,
    successful_endpoints: 0,
    total_endpoints: 27,
    collection_date: new Date().toISOString()
  };

  let successCount = 0;

  // 배치로 엔드포인트 처리
  for (let i = 0; i < endpoints.length; i += 3) {
    const batch = endpoints.slice(i, i + 3);
    const promises = batch.map(endpoint => {
      const baseUrl = endpoint.service === 'common' ? COMMON_COST_BASE_URL : INDIVIDUAL_COST_BASE_URL;
      const url = `${baseUrl}/${endpoint.url}?serviceKey=${encodedApiKey}&kaptCode=${kaptCode}&searchDate=${searchDate}&type=json`;
      return fetchWithRetry(url).then(response => ({ endpoint, response })).catch(error => ({ endpoint, error }));
    });

    const batchResults = await Promise.allSettled(promises);
    
    for (const promiseResult of batchResults) {
      if (promiseResult.status === 'fulfilled' && 'response' in promiseResult.value) {
        const { endpoint, response } = promiseResult.value;
        try {
          const json = await response.json();
          if (json.response?.body?.item && json.response?.header?.resultCode === '00') {
            const value = parseInt(json.response.body.item[endpoint.key] || 0);
            result[endpoint.dbField] = value;
            
            if (endpoint.service === 'common') {
              result.common_fee += value;
            } else {
              result.individual_fee += value;
            }
            successCount++;
          }
        } catch (parseError) {
          console.error(`파싱 에러 ${endpoint.name}:`, parseError);
        }
      }
    }
    
    // 배치 간 대기
    await new Promise(resolve => setTimeout(resolve, 300));
  }

  result.total_fee = result.common_fee + result.individual_fee;
  result.successful_endpoints = successCount;
  result.success_rate = ((successCount / 27) * 100).toFixed(2);

  return result;
}

// DB에 저장
async function saveToDatabase(data: any) {
  const { error } = await supabase
    .from('management_fees')
    .upsert(data, {
      onConflict: 'kapt_code,year,month'
    });

  if (error) {
    throw error;
  }
  return true;
}

// 아파트 목록 조회
async function getActiveApartments(limit: number = 50, offset: number = 0) {
  const { data, error } = await supabase
    .from('apartments')
    .select('kapt_code, name')
    .eq('is_active', true)
    .range(offset, offset + limit - 1);

  if (error) {
    throw error;
  }

  return data || [];
}

export async function POST(request: NextRequest) {
  const body = await request.json();
  const { secret, year, months, limit, offset } = body;

  // 보안 검증
  if (secret !== SCHEDULER_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const targetYear = year || 2024;
  const targetMonths = months || [new Date().getMonth() + 1]; // 기본값: 현재 월
  const batchLimit = limit || 20;
  const batchOffset = offset || 0;

  try {
    console.log(`🚀 스케줄러 시작: ${targetYear}년 ${targetMonths.join(', ')}월`);
    console.log(`처리 대상: ${batchLimit}개 아파트 (offset: ${batchOffset})`);

    const apartments = await getActiveApartments(batchLimit, batchOffset);
    
    let totalProcessed = 0;
    let totalSaved = 0;
    let totalErrors = 0;

    for (const apartment of apartments) {
      for (const month of targetMonths) {
        try {
          const data = await collectManagementFeeForApartment(
            apartment.kapt_code, 
            apartment.name, 
            targetYear, 
            month
          );
          
          await saveToDatabase(data);
          totalSaved++;
          
          console.log(`✅ ${apartment.name} ${targetYear}-${month}: ${data.total_fee?.toLocaleString()}원 (성공률: ${data.success_rate}%)`);
          
        } catch (error) {
          console.error(`❌ 에러 ${apartment.kapt_code} ${targetYear}-${month}:`, error);
          totalErrors++;
        }
        
        totalProcessed++;
        
        // 요청 간 대기
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    console.log(`✅ 스케줄러 완료 - 처리: ${totalProcessed}, 성공: ${totalSaved}, 에러: ${totalErrors}`);

    return NextResponse.json({
      success: true,
      message: 'Scheduled collection completed',
      processed: totalProcessed,
      saved: totalSaved,
      errors: totalErrors,
      apartments: apartments.length
    });

  } catch (error) {
    console.error('스케줄러 에러:', error);
    return NextResponse.json(
      { 
        error: 'Scheduler failed', 
        details: error instanceof Error ? error.message : 'Unknown error' 
      },
      { status: 500 }
    );
  }
}

// GET 요청으로 상태 확인
export async function GET() {
  return NextResponse.json({
    message: 'Management fee scheduler is running',
    status: 'active',
    lastRun: new Date().toISOString()
  });
}