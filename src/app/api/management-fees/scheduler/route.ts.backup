import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

const API_KEY = process.env.NEXT_PUBLIC_DATA_GO_KR_SERVICE_KEY;
const SCHEDULER_SECRET = process.env.SCHEDULER_SECRET || 'your-scheduler-secret';
const COMMON_COST_BASE_URL = 'https://apis.data.go.kr/1613000/AptCmnuseManageCostServiceV2';
const INDIVIDUAL_COST_BASE_URL = 'https://apis.data.go.kr/1613000/AptIndvdlzManageCostServiceV2';

// ê°•í™”ëœ ì¬ì‹œë„ ë¡œì§
async function fetchWithRetry(url: string, maxRetries: number = 5, delayMs: number = 1000): Promise<Response> {
  let lastError: Error = new Error('Unknown error');
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000);
      
      const response = await fetch(url, {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'Mozilla/5.0 (compatible; ManagementFeeBot/1.0)',
          'Connection': 'keep-alive',
          'Cache-Control': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      lastError = error as Error;
      
      if (attempt < maxRetries) {
        const delay = Math.min(delayMs * attempt, 5000);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
}

// ì•„íŒŒíŠ¸ë³„ ê´€ë¦¬ë¹„ ìˆ˜ì§‘ í•¨ìˆ˜ (ê°„ì†Œí™”ëœ ë²„ì „)
async function collectManagementFeeForApartment(kaptCode: string, kaptName: string, year: number, month: number) {
  const searchDate = `${year}${month.toString().padStart(2, '0')}`;
  const encodedApiKey = encodeURIComponent(API_KEY!);
  
  // ì—”ë“œí¬ì¸íŠ¸ ì •ì˜
  const endpoints = [
    // ê³µìš©ê´€ë¦¬ë¹„ (17ê°œ)
    { name: 'ì²­ì†Œë¹„', url: 'getHsmpCleaningCostInfoV2', key: 'cleanCost', dbField: 'cleaning_cost', service: 'common' },
    { name: 'ê²½ë¹„ë¹„', url: 'getHsmpGuardCostInfoV2', key: 'guardCost', dbField: 'guard_cost', service: 'common' },
    { name: 'ì†Œë…ë¹„', url: 'getHsmpDisinfectionCostInfoV2', key: 'disinfCost', dbField: 'disinfection_cost', service: 'common' },
    { name: 'ìŠ¹ê°•ê¸°ìœ ì§€ë¹„', url: 'getHsmpElevatorMntncCostInfoV2', key: 'elevCost', dbField: 'elevator_cost', service: 'common' },
    { name: 'ìˆ˜ì„ ë¹„', url: 'getHsmpRepairsCostInfoV2', key: 'lrefCost1', dbField: 'repairs_cost', service: 'common' },
    { name: 'ì‹œì„¤ìœ ì§€ë¹„', url: 'getHsmpFacilityMntncCostInfoV2', key: 'lrefCost2', dbField: 'facility_cost', service: 'common' },
    { name: 'ì°¨ëŸ‰ìœ ì§€ë¹„', url: 'getHsmpVhcleMntncCostInfoV2', key: 'fuelCost', dbField: 'vehicle_cost', service: 'common' },
    { name: 'ì¬í•´ì˜ˆë°©ë¹„', url: 'getHsmpDisasterPreventionCostInfoV2', key: 'lrefCost4', dbField: 'disaster_cost', service: 'common' },
    { name: 'ê¸°íƒ€ë¶€ëŒ€ë¹„ìš©', url: 'getHsmpEtcCostInfoV2', key: 'careItemCost', dbField: 'etc_cost', service: 'common' },
    { name: 'ì œì‚¬ë¬´ë¹„', url: 'getHsmpOfcrkCostInfoV2', key: 'officeSupply', dbField: 'office_cost', service: 'common' },
    { name: 'í”¼ë³µë¹„', url: 'getHsmpClothingCostInfoV2', key: 'clothesCost', dbField: 'clothing_cost', service: 'common' },
    { name: 'êµìœ¡í›ˆë ¨ë¹„', url: 'getHsmpEduTraingCostInfoV2', key: 'eduCost', dbField: 'education_cost', service: 'common' },
    { name: 'ì§€ëŠ¥í˜•í™ˆë„¤íŠ¸ì›Œí¬ì„¤ë¹„ìœ ì§€ë¹„', url: 'getHsmpHomeNetworkMntncCostInfoV2', key: 'hnetwCost', dbField: 'home_network_cost', service: 'common' },
    { name: 'ì•ˆì „ì ê²€ë¹„', url: 'getHsmpSafetyCheckUpCostInfoV2', key: 'lrefCost3', dbField: 'safety_cost', service: 'common' },
    { name: 'ìœ„íƒê´€ë¦¬ìˆ˜ìˆ˜ë£Œ', url: 'getHsmpConsignManageFeeInfoV2', key: 'manageCost', dbField: 'management_cost', service: 'common' },
    { name: 'ì¸ê±´ë¹„', url: 'getHsmpLaborCostInfoV2', key: 'pay', dbField: 'labor_cost', service: 'common' },
    { name: 'ì œì„¸ê³µê³¼ê¸ˆ', url: 'getHsmpTaxdueInfoV2', key: 'telCost', dbField: 'tax_cost', service: 'common' },
    // ê°œë³„ì‚¬ìš©ë£Œ (10ê°œ)
    { name: 'ë‚œë°©ë¹„', url: 'getHsmpHeatCostInfoV2', key: 'heatC', dbField: 'heating_cost', service: 'individual' },
    { name: 'ê¸‰íƒ•ë¹„', url: 'getHsmpHotWaterCostInfoV2', key: 'waterHotC', dbField: 'hot_water_cost', service: 'individual' },
    { name: 'ì „ê¸°ë£Œ', url: 'getHsmpElectricityCostInfoV2', key: 'electC', dbField: 'electricity_cost', service: 'individual' },
    { name: 'ìˆ˜ë„ë£Œ', url: 'getHsmpWaterCostInfoV2', key: 'waterCoolC', dbField: 'water_cost', service: 'individual' },
    { name: 'ê°€ìŠ¤ì‚¬ìš©ë£Œ', url: 'getHsmpGasRentalFeeInfoV2', key: 'gasC', dbField: 'gas_cost', service: 'individual' },
    { name: 'ìƒí™œíê¸°ë¬¼ìˆ˜ìˆ˜ë£Œ', url: 'getHsmpDomesticWasteFeeInfoV2', key: 'scrap', dbField: 'waste_cost', service: 'individual' },
    { name: 'ì…ì£¼ìëŒ€í‘œíšŒì˜ìš´ì˜ë¹„', url: 'getHsmpMovingInRepresentationMtgInfoV2', key: 'preMeet', dbField: 'meeting_cost', service: 'individual' },
    { name: 'ê±´ë¬¼ë³´í—˜ë£Œ', url: 'getHsmpBuildingInsuranceFeeInfoV2', key: 'buildInsu', dbField: 'insurance_cost', service: 'individual' },
    { name: 'ì„ ê±°ê´€ë¦¬ìœ„ì›íšŒìš´ì˜ë¹„', url: 'getHsmpElectionOrpnsInfoV2', key: 'electionMng', dbField: 'election_cost', service: 'individual' },
    { name: 'ì •í™”ì¡°ì˜¤ë¬¼ìˆ˜ìˆ˜ë£Œ', url: 'getHsmpWaterPurifierTankFeeInfoV2', key: 'purifi', dbField: 'purifier_cost', service: 'individual' }
  ];

  const result: any = {
    kapt_code: kaptCode,
    kapt_name: kaptName,
    year,
    month,
    common_fee: 0,
    individual_fee: 0,
    total_fee: 0,
    success_rate: 0,
    successful_endpoints: 0,
    total_endpoints: 27,
    collection_date: new Date().toISOString()
  };

  let successCount = 0;

  // ë°°ì¹˜ë¡œ ì—”ë“œí¬ì¸íŠ¸ ì²˜ë¦¬
  for (let i = 0; i < endpoints.length; i += 3) {
    const batch = endpoints.slice(i, i + 3);
    const promises = batch.map(endpoint => {
      const baseUrl = endpoint.service === 'common' ? COMMON_COST_BASE_URL : INDIVIDUAL_COST_BASE_URL;
      const url = `${baseUrl}/${endpoint.url}?serviceKey=${encodedApiKey}&kaptCode=${kaptCode}&searchDate=${searchDate}&type=json`;
      return fetchWithRetry(url).then(response => ({ endpoint, response })).catch(error => ({ endpoint, error }));
    });

    const batchResults = await Promise.allSettled(promises);
    
    for (const promiseResult of batchResults) {
      if (promiseResult.status === 'fulfilled' && 'response' in promiseResult.value) {
        const { endpoint, response } = promiseResult.value;
        try {
          const json = await response.json();
          if (json.response?.body?.item && json.response?.header?.resultCode === '00') {
            const value = parseInt(json.response.body.item[endpoint.key] || 0);
            result[endpoint.dbField] = value;
            
            if (endpoint.service === 'common') {
              result.common_fee += value;
            } else {
              result.individual_fee += value;
            }
            successCount++;
          }
        } catch (parseError) {
          console.error(`íŒŒì‹± ì—ëŸ¬ ${endpoint.name}:`, parseError);
        }
      }
    }
    
    // ë°°ì¹˜ ê°„ ëŒ€ê¸°
    await new Promise(resolve => setTimeout(resolve, 300));
  }

  result.total_fee = result.common_fee + result.individual_fee;
  result.successful_endpoints = successCount;
  result.success_rate = ((successCount / 27) * 100).toFixed(2);

  return result;
}

// DBì— ì €ì¥
async function saveToDatabase(data: any) {
  const { error } = await supabase
    .from('management_fees')
    .upsert(data, {
      onConflict: 'kapt_code,year,month'
    });

  if (error) {
    throw error;
  }
  return true;
}

// ì•„íŒŒíŠ¸ ëª©ë¡ ì¡°íšŒ
async function getActiveApartments(limit: number = 50, offset: number = 0) {
  const { data, error } = await supabase
    .from('apartments')
    .select('kapt_code, name')
    .eq('is_active', true)
    .range(offset, offset + limit - 1);

  if (error) {
    throw error;
  }

  return data || [];
}

export async function POST(request: NextRequest) {
  const body = await request.json();
  const { secret, year, months, limit, offset } = body;

  // ë³´ì•ˆ ê²€ì¦
  if (secret !== SCHEDULER_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const targetYear = year || 2024;
  const targetMonths = months || [new Date().getMonth() + 1]; // ê¸°ë³¸ê°’: í˜„ì¬ ì›”
  const batchLimit = limit || 20;
  const batchOffset = offset || 0;

  try {
    console.log(`ğŸš€ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘: ${targetYear}ë…„ ${targetMonths.join(', ')}ì›”`);
    console.log(`ì²˜ë¦¬ ëŒ€ìƒ: ${batchLimit}ê°œ ì•„íŒŒíŠ¸ (offset: ${batchOffset})`);

    const apartments = await getActiveApartments(batchLimit, batchOffset);
    
    let totalProcessed = 0;
    let totalSaved = 0;
    let totalErrors = 0;

    for (const apartment of apartments) {
      for (const month of targetMonths) {
        try {
          const data = await collectManagementFeeForApartment(
            apartment.kapt_code, 
            apartment.name, 
            targetYear, 
            month
          );
          
          await saveToDatabase(data);
          totalSaved++;
          
          console.log(`âœ… ${apartment.name} ${targetYear}-${month}: ${data.total_fee?.toLocaleString()}ì› (ì„±ê³µë¥ : ${data.success_rate}%)`);
          
        } catch (error) {
          console.error(`âŒ ì—ëŸ¬ ${apartment.kapt_code} ${targetYear}-${month}:`, error);
          totalErrors++;
        }
        
        totalProcessed++;
        
        // ìš”ì²­ ê°„ ëŒ€ê¸°
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    console.log(`âœ… ìŠ¤ì¼€ì¤„ëŸ¬ ì™„ë£Œ - ì²˜ë¦¬: ${totalProcessed}, ì„±ê³µ: ${totalSaved}, ì—ëŸ¬: ${totalErrors}`);

    return NextResponse.json({
      success: true,
      message: 'Scheduled collection completed',
      processed: totalProcessed,
      saved: totalSaved,
      errors: totalErrors,
      apartments: apartments.length
    });

  } catch (error) {
    console.error('ìŠ¤ì¼€ì¤„ëŸ¬ ì—ëŸ¬:', error);
    return NextResponse.json(
      { 
        error: 'Scheduler failed', 
        details: error instanceof Error ? error.message : 'Unknown error' 
      },
      { status: 500 }
    );
  }
}

// GET ìš”ì²­ìœ¼ë¡œ ìƒíƒœ í™•ì¸
export async function GET() {
  return NextResponse.json({
    message: 'Management fee scheduler is running',
    status: 'active',
    lastRun: new Date().toISOString()
  });
}